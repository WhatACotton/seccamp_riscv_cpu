#![doc = "Peripheral access API for CPU_RISCV_CHISEL_BOOK microcontrollers (generated using svd2rust v0.29.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.29.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + PartialEq + From<Self>;
    }
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {
        #[doc = " Result from a call to `read` and argument to `modify`."]
        type Reader: From<R<Self>> + core::ops::Deref<Target = R<Self>>;
    }
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Writer type argument to `write`, et al."]
        type Writer: From<W<Self>> + core::ops::DerefMut<Target = W<Self>>;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> REG::Reader {
            REG::Reader::from(R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            })
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&REG::Reader, &'w mut REG::Writer) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &REG::Reader::from(R {
                        bits,
                        _reg: marker::PhantomData,
                    }),
                    &mut REG::Writer::from(W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    }),
                )
                .bits,
            );
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub struct R<REG: RegisterSpec + ?Sized> {
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub struct W<REG: RegisterSpec + ?Sized> {
        #[doc = "Writable bits"]
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Read datasheet or reference manual to find what values are allowed to pass."]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc(hidden)]
    pub struct FieldReaderRaw<FI = u8>
    where
        FI: FieldSpec,
    {
        pub(crate) bits: FI::Ux,
        _reg: marker::PhantomData<FI>,
    }
    impl<FI: FieldSpec> FieldReaderRaw<FI> {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: FI::Ux) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
    }
    #[doc(hidden)]
    pub struct BitReaderRaw<FI = bool> {
        pub(crate) bits: bool,
        _reg: marker::PhantomData<FI>,
    }
    impl<FI> BitReaderRaw<FI> {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: bool) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = FieldReaderRaw<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = BitReaderRaw<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    #[doc(hidden)]
    pub struct Safe;
    #[doc(hidden)]
    pub struct Unsafe;
    #[doc(hidden)]
    pub struct FieldWriterRaw<'a, REG, const WI: u8, const O: u8, FI = u8, Safety = Unsafe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        pub(crate) w: &'a mut REG::Writer,
        _field: marker::PhantomData<(FI, Safety)>,
    }
    impl<'a, REG, const WI: u8, const O: u8, FI, Safety> FieldWriterRaw<'a, REG, WI, O, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Creates a new instance of the writer"]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(w: &'a mut REG::Writer) -> Self {
            Self {
                w,
                _field: marker::PhantomData,
            }
        }
    }
    #[doc(hidden)]
    pub struct BitWriterRaw<'a, REG, const O: u8, FI = bool, M = BitM>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        pub(crate) w: &'a mut REG::Writer,
        _field: marker::PhantomData<(FI, M)>,
    }
    impl<'a, REG, const O: u8, FI, M> BitWriterRaw<'a, REG, O, FI, M>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Creates a new instance of the writer"]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(w: &'a mut REG::Writer) -> Self {
            Self {
                w,
                _field: marker::PhantomData,
            }
        }
    }
    #[doc = " Write field Proxy with unsafe `bits`"]
    pub type FieldWriter<'a, REG, const WI: u8, const O: u8, FI = u8> =
        FieldWriterRaw<'a, REG, WI, O, FI, Unsafe>;
    #[doc = " Write field Proxy with safe `bits`"]
    pub type FieldWriterSafe<'a, REG, const WI: u8, const O: u8, FI = u8> =
        FieldWriterRaw<'a, REG, WI, O, FI, Safe>;
    impl<'a, REG, const WI: u8, const OF: u8, FI> FieldWriter<'a, REG, WI, OF, FI>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
    }
    impl<'a, REG, const WI: u8, const OF: u8, FI> FieldWriterSafe<'a, REG, WI, OF, FI>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, const O: u8, FI = bool> = BitWriterRaw<'a, REG, O, FI, $mwv>;
            impl<'a, REG, const OF: u8, FI> $writer<'a, REG, OF, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
            }
        };
    }
    macro_rules! impl_bit_proxy {
        ($ writer : ident) => {
            impl<'a, REG, const OF: u8, FI> $writer<'a, REG, OF, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut REG::Writer {
                    self.w.bits &= !(REG::Ux::one() << OF);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::one()) << OF;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, const WI: u8, const OF: u8, FI> FieldWriter<'a, REG, WI, OF, FI>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut REG::Writer {
            self.w.bits &= !(REG::Ux::mask::<WI>() << OF);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    impl<'a, REG, const WI: u8, const OF: u8, FI> FieldWriterSafe<'a, REG, WI, OF, FI>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn bits(self, value: FI::Ux) -> &'a mut REG::Writer {
            self.w.bits &= !(REG::Ux::mask::<WI>() << OF);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
            self.bits(FI::Ux::from(variant))
        }
    }
    impl_bit_proxy!(BitWriter);
    impl_bit_proxy!(BitWriter1S);
    impl_bit_proxy!(BitWriter0C);
    impl_bit_proxy!(BitWriter1C);
    impl_bit_proxy!(BitWriter0S);
    impl_bit_proxy!(BitWriter1T);
    impl_bit_proxy!(BitWriter0T);
    impl<'a, REG, const OF: u8, FI> BitWriter<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= REG::Ux::one() << OF;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(REG::Ux::one() << OF);
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter1S<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= REG::Ux::one() << OF;
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter0C<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(REG::Ux::one() << OF);
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter1C<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut REG::Writer {
            self.w.bits |= REG::Ux::one() << OF;
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter0S<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut REG::Writer {
            self.w.bits &= !(REG::Ux::one() << OF);
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter1T<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= REG::Ux::one() << OF;
            self.w
        }
    }
    impl<'a, REG, const OF: u8, FI> BitWriter0T<'a, REG, OF, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(REG::Ux::one() << OF);
            self.w
        }
    }
    #[doc = " Access an array of `COUNT` items of type `T` with the items `STRIDE` bytes"]
    #[doc = " apart.  This is a zero-sized-type.  No objects of this type are ever"]
    #[doc = " actually created, it is only a convenience for wrapping pointer arithmetic."]
    #[doc = ""]
    #[doc = " There is no safe way to produce items of this type.  Unsafe code can produce"]
    #[doc = " references by pointer casting.  It is up to the unsafe code doing that, to"]
    #[doc = " ensure that the memory really is backed by appropriate content."]
    #[doc = ""]
    #[doc = " Typically, this is used for accessing hardware registers."]
    pub struct ArrayProxy<T, const COUNT: usize, const STRIDE: usize> {
        #[doc = " As well as providing a PhantomData, this field is non-public, and"]
        #[doc = " therefore ensures that code outside of this module can never create"]
        #[doc = " an ArrayProxy."]
        _array: marker::PhantomData<T>,
    }
    #[allow(clippy::len_without_is_empty)]
    impl<T, const C: usize, const S: usize> ArrayProxy<T, C, S> {
        #[doc = " Get a reference from an [ArrayProxy] with no bounds checking."]
        pub unsafe fn get_ref(&self, index: usize) -> &T {
            let base = self as *const Self as usize;
            let address = base + S * index;
            &*(address as *const T)
        }
        #[doc = " Get a reference from an [ArrayProxy], or return `None` if the index"]
        #[doc = " is out of bounds."]
        pub fn get(&self, index: usize) -> Option<&T> {
            if index < C {
                Some(unsafe { self.get_ref(index) })
            } else {
                None
            }
        }
        #[doc = " Return the number of items."]
        pub fn len(&self) -> usize {
            C
        }
    }
    impl<T, const C: usize, const S: usize> core::ops::Index<usize> for ArrayProxy<T, C, S> {
        type Output = T;
        fn index(&self, index: usize) -> &T {
            #[allow(clippy::no_effect)]
            [(); C][index];
            unsafe { self.get_ref(index) }
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 0] = [];
#[doc = "GPIO"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0xa000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "GPIO"]
pub mod gpio {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - "]
        pub segled_out_l: SEGLED_OUT_L,
        _reserved1: [u8; 0x0c],
        #[doc = "0x10 - "]
        pub segled_out_h: SEGLED_OUT_H,
        _reserved2: [u8; 0x0c],
        #[doc = "0x20 - "]
        pub matrix_out_l: MATRIX_OUT_L,
        _reserved3: [u8; 0x0c],
        #[doc = "0x30 - "]
        pub matrix_out_h: MATRIX_OUT_H,
        _reserved4: [u8; 0x0c],
        #[doc = "0x40 - "]
        pub led_out: LED_OUT,
        _reserved5: [u8; 0x10],
        #[doc = "0x54 - "]
        pub sw_in: SW_IN,
    }
    #[doc = "SEGLED_OUT_L (rw) register accessor: an alias for `Reg<SEGLED_OUT_L_SPEC>`"]
    pub type SEGLED_OUT_L = crate::Reg<segled_out_l::SEGLED_OUT_L_SPEC>;
    #[doc = ""]
    pub mod segled_out_l {
        #[doc = "Register `SEGLED_OUT_L` reader"]
        pub struct R(crate::R<SEGLED_OUT_L_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SEGLED_OUT_L_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SEGLED_OUT_L_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SEGLED_OUT_L_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `SEGLED_OUT_L` writer"]
        pub struct W(crate::W<SEGLED_OUT_L_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SEGLED_OUT_L_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SEGLED_OUT_L_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SEGLED_OUT_L_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `OUT` reader - "]
        pub type OUT_R = crate::FieldReader<u32>;
        #[doc = "Field `OUT` writer - "]
        pub type OUT_W<'a, const O: u8> = crate::FieldWriterSafe<'a, SEGLED_OUT_L_SPEC, 32, O, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn out(&self) -> OUT_R {
                OUT_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn out(&mut self) -> OUT_W<0> {
                OUT_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub fn bits(&mut self, bits: u32) -> &mut Self {
                unsafe { self.0.bits(bits) };
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [segled_out_l](index.html) module"]
        pub struct SEGLED_OUT_L_SPEC;
        impl crate::RegisterSpec for SEGLED_OUT_L_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [segled_out_l::R](R) reader structure"]
        impl crate::Readable for SEGLED_OUT_L_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [segled_out_l::W](W) writer structure"]
        impl crate::Writable for SEGLED_OUT_L_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets SEGLED_OUT_L to value 0"]
        impl crate::Resettable for SEGLED_OUT_L_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "SEGLED_OUT_H (rw) register accessor: an alias for `Reg<SEGLED_OUT_H_SPEC>`"]
    pub type SEGLED_OUT_H = crate::Reg<segled_out_h::SEGLED_OUT_H_SPEC>;
    #[doc = ""]
    pub mod segled_out_h {
        #[doc = "Register `SEGLED_OUT_H` reader"]
        pub struct R(crate::R<SEGLED_OUT_H_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SEGLED_OUT_H_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SEGLED_OUT_H_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SEGLED_OUT_H_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `SEGLED_OUT_H` writer"]
        pub struct W(crate::W<SEGLED_OUT_H_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SEGLED_OUT_H_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SEGLED_OUT_H_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SEGLED_OUT_H_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `OUT` reader - "]
        pub type OUT_R = crate::FieldReader<u16>;
        #[doc = "Field `OUT` writer - "]
        pub type OUT_W<'a, const O: u8> = crate::FieldWriterSafe<'a, SEGLED_OUT_H_SPEC, 16, O, u16>;
        impl R {
            #[doc = "Bits 0:15"]
            #[inline(always)]
            pub fn out(&self) -> OUT_R {
                OUT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15"]
            #[inline(always)]
            #[must_use]
            pub fn out(&mut self) -> OUT_W<0> {
                OUT_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [segled_out_h](index.html) module"]
        pub struct SEGLED_OUT_H_SPEC;
        impl crate::RegisterSpec for SEGLED_OUT_H_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [segled_out_h::R](R) reader structure"]
        impl crate::Readable for SEGLED_OUT_H_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [segled_out_h::W](W) writer structure"]
        impl crate::Writable for SEGLED_OUT_H_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets SEGLED_OUT_H to value 0"]
        impl crate::Resettable for SEGLED_OUT_H_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "MATRIX_OUT_L (rw) register accessor: an alias for `Reg<MATRIX_OUT_L_SPEC>`"]
    pub type MATRIX_OUT_L = crate::Reg<matrix_out_l::MATRIX_OUT_L_SPEC>;
    #[doc = ""]
    pub mod matrix_out_l {
        #[doc = "Register `MATRIX_OUT_L` reader"]
        pub struct R(crate::R<MATRIX_OUT_L_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MATRIX_OUT_L_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MATRIX_OUT_L_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MATRIX_OUT_L_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `MATRIX_OUT_L` writer"]
        pub struct W(crate::W<MATRIX_OUT_L_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MATRIX_OUT_L_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MATRIX_OUT_L_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MATRIX_OUT_L_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `OUT` reader - "]
        pub type OUT_R = crate::FieldReader<u32>;
        #[doc = "Field `OUT` writer - "]
        pub type OUT_W<'a, const O: u8> = crate::FieldWriterSafe<'a, MATRIX_OUT_L_SPEC, 32, O, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn out(&self) -> OUT_R {
                OUT_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn out(&mut self) -> OUT_W<0> {
                OUT_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub fn bits(&mut self, bits: u32) -> &mut Self {
                unsafe { self.0.bits(bits) };
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [matrix_out_l](index.html) module"]
        pub struct MATRIX_OUT_L_SPEC;
        impl crate::RegisterSpec for MATRIX_OUT_L_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [matrix_out_l::R](R) reader structure"]
        impl crate::Readable for MATRIX_OUT_L_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [matrix_out_l::W](W) writer structure"]
        impl crate::Writable for MATRIX_OUT_L_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets MATRIX_OUT_L to value 0"]
        impl crate::Resettable for MATRIX_OUT_L_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "MATRIX_OUT_H (rw) register accessor: an alias for `Reg<MATRIX_OUT_H_SPEC>`"]
    pub type MATRIX_OUT_H = crate::Reg<matrix_out_h::MATRIX_OUT_H_SPEC>;
    #[doc = ""]
    pub mod matrix_out_h {
        #[doc = "Register `MATRIX_OUT_H` reader"]
        pub struct R(crate::R<MATRIX_OUT_H_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MATRIX_OUT_H_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MATRIX_OUT_H_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MATRIX_OUT_H_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `MATRIX_OUT_H` writer"]
        pub struct W(crate::W<MATRIX_OUT_H_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MATRIX_OUT_H_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MATRIX_OUT_H_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MATRIX_OUT_H_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `OUT` reader - "]
        pub type OUT_R = crate::FieldReader<u32>;
        #[doc = "Field `OUT` writer - "]
        pub type OUT_W<'a, const O: u8> = crate::FieldWriterSafe<'a, MATRIX_OUT_H_SPEC, 32, O, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn out(&self) -> OUT_R {
                OUT_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn out(&mut self) -> OUT_W<0> {
                OUT_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub fn bits(&mut self, bits: u32) -> &mut Self {
                unsafe { self.0.bits(bits) };
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [matrix_out_h](index.html) module"]
        pub struct MATRIX_OUT_H_SPEC;
        impl crate::RegisterSpec for MATRIX_OUT_H_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [matrix_out_h::R](R) reader structure"]
        impl crate::Readable for MATRIX_OUT_H_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [matrix_out_h::W](W) writer structure"]
        impl crate::Writable for MATRIX_OUT_H_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets MATRIX_OUT_H to value 0"]
        impl crate::Resettable for MATRIX_OUT_H_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "LED_OUT (rw) register accessor: an alias for `Reg<LED_OUT_SPEC>`"]
    pub type LED_OUT = crate::Reg<led_out::LED_OUT_SPEC>;
    #[doc = ""]
    pub mod led_out {
        #[doc = "Register `LED_OUT` reader"]
        pub struct R(crate::R<LED_OUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LED_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LED_OUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LED_OUT_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `LED_OUT` writer"]
        pub struct W(crate::W<LED_OUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LED_OUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<LED_OUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<LED_OUT_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `OUT` reader - "]
        pub type OUT_R = crate::FieldReader<u32>;
        #[doc = "Field `OUT` writer - "]
        pub type OUT_W<'a, const O: u8> = crate::FieldWriterSafe<'a, LED_OUT_SPEC, 32, O, u32>;
        impl R {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            pub fn out(&self) -> OUT_R {
                OUT_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31"]
            #[inline(always)]
            #[must_use]
            pub fn out(&mut self) -> OUT_W<0> {
                OUT_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub fn bits(&mut self, bits: u32) -> &mut Self {
                unsafe { self.0.bits(bits) };
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [led_out](index.html) module"]
        pub struct LED_OUT_SPEC;
        impl crate::RegisterSpec for LED_OUT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [led_out::R](R) reader structure"]
        impl crate::Readable for LED_OUT_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [led_out::W](W) writer structure"]
        impl crate::Writable for LED_OUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets LED_OUT to value 0"]
        impl crate::Resettable for LED_OUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "SW_IN (rw) register accessor: an alias for `Reg<SW_IN_SPEC>`"]
    pub type SW_IN = crate::Reg<sw_in::SW_IN_SPEC>;
    #[doc = ""]
    pub mod sw_in {
        #[doc = "Register `SW_IN` reader"]
        pub struct R(crate::R<SW_IN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SW_IN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SW_IN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SW_IN_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `SW_IN` writer"]
        pub struct W(crate::W<SW_IN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SW_IN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SW_IN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SW_IN_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `IN` reader - "]
        pub type IN_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn in_(&self) -> IN_R {
                IN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sw_in](index.html) module"]
        pub struct SW_IN_SPEC;
        impl crate::RegisterSpec for SW_IN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [sw_in::R](R) reader structure"]
        impl crate::Readable for SW_IN_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [sw_in::W](W) writer structure"]
        impl crate::Writable for SW_IN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets SW_IN to value 0"]
        impl crate::Resettable for SW_IN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[doc = "Simple UART"]
pub struct UART {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART {}
impl UART {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xa000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART").finish()
    }
}
#[doc = "Simple UART"]
pub mod uart {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved_0_rxd: [u8; 0x04],
        #[doc = "0x04 - "]
        pub status: STATUS,
    }
    impl RegisterBlock {
        #[doc = "0x00 - "]
        #[inline(always)]
        pub const fn rxd(&self) -> &RXD {
            unsafe { &*(self as *const Self).cast::<u8>().add(0usize).cast() }
        }
        #[doc = "0x00 - "]
        #[inline(always)]
        pub const fn txd(&self) -> &TXD {
            unsafe { &*(self as *const Self).cast::<u8>().add(0usize).cast() }
        }
    }
    #[doc = "TXD (rw) register accessor: an alias for `Reg<TXD_SPEC>`"]
    pub type TXD = crate::Reg<txd::TXD_SPEC>;
    #[doc = ""]
    pub mod txd {
        #[doc = "Register `TXD` reader"]
        pub struct R(crate::R<TXD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TXD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TXD_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `TXD` writer"]
        pub struct W(crate::W<TXD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TXD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TXD_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `DATA` writer - "]
        pub type DATA_W<'a, const O: u8> = crate::FieldWriterSafe<'a, TXD_SPEC, 8, O>;
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<0> {
                DATA_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txd](index.html) module"]
        pub struct TXD_SPEC;
        impl crate::RegisterSpec for TXD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [txd::R](R) reader structure"]
        impl crate::Readable for TXD_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [txd::W](W) writer structure"]
        impl crate::Writable for TXD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets TXD to value 0"]
        impl crate::Resettable for TXD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "RXD (rw) register accessor: an alias for `Reg<RXD_SPEC>`"]
    pub type RXD = crate::Reg<rxd::RXD_SPEC>;
    #[doc = ""]
    pub mod rxd {
        #[doc = "Register `RXD` reader"]
        pub struct R(crate::R<RXD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RXD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RXD_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `RXD` writer"]
        pub struct W(crate::W<RXD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RXD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RXD_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `RXD` reader - "]
        pub type RXD_R = crate::FieldReader;
        #[doc = "Field `RXD_VALID` reader - "]
        pub type RXD_VALID_R = crate::BitReader;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn rxd(&self) -> RXD_R {
                RXD_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn rxd_valid(&self) -> RXD_VALID_R {
                RXD_VALID_R::new(((self.bits >> 16) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxd](index.html) module"]
        pub struct RXD_SPEC;
        impl crate::RegisterSpec for RXD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [rxd::R](R) reader structure"]
        impl crate::Readable for RXD_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [rxd::W](W) writer structure"]
        impl crate::Writable for RXD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets RXD to value 0"]
        impl crate::Resettable for RXD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    #[doc = ""]
    pub mod status {
        #[doc = "Register `STATUS` reader"]
        pub struct R(crate::R<STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `STATUS` writer"]
        pub struct W(crate::W<STATUS_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATUS_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATUS_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `TXREADY` reader - "]
        pub type TXREADY_R = crate::BitReader<TXREADY_A>;
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TXREADY_A {
            #[doc = "1: `1`"]
            READY = 1,
            #[doc = "0: `0`"]
            NOTREADY = 0,
        }
        impl From<TXREADY_A> for bool {
            #[inline(always)]
            fn from(variant: TXREADY_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TXREADY_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXREADY_A {
                match self.bits {
                    true => TXREADY_A::READY,
                    false => TXREADY_A::NOTREADY,
                }
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == TXREADY_A::READY
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_notready(&self) -> bool {
                *self == TXREADY_A::NOTREADY
            }
        }
        #[doc = "Field `TXREADY` writer - "]
        pub type TXREADY_W<'a, const O: u8> = crate::BitWriter<'a, STATUS_SPEC, O, TXREADY_A>;
        impl<'a, const O: u8> TXREADY_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ready(self) -> &'a mut W {
                self.variant(TXREADY_A::READY)
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn notready(self) -> &'a mut W {
                self.variant(TXREADY_A::NOTREADY)
            }
        }
        #[doc = "Field `RXREADY` reader - "]
        pub type RXREADY_R = crate::BitReader<RXREADY_A>;
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXREADY_A {
            #[doc = "1: `1`"]
            READY = 1,
            #[doc = "0: `0`"]
            NOTREADY = 0,
        }
        impl From<RXREADY_A> for bool {
            #[inline(always)]
            fn from(variant: RXREADY_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXREADY_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXREADY_A {
                match self.bits {
                    true => RXREADY_A::READY,
                    false => RXREADY_A::NOTREADY,
                }
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == RXREADY_A::READY
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_notready(&self) -> bool {
                *self == RXREADY_A::NOTREADY
            }
        }
        #[doc = "Field `RXREADY` writer - "]
        pub type RXREADY_W<'a, const O: u8> = crate::BitWriter<'a, STATUS_SPEC, O, RXREADY_A>;
        impl<'a, const O: u8> RXREADY_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ready(self) -> &'a mut W {
                self.variant(RXREADY_A::READY)
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn notready(self) -> &'a mut W {
                self.variant(RXREADY_A::NOTREADY)
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn txready(&self) -> TXREADY_R {
                TXREADY_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn rxready(&self) -> RXREADY_R {
                RXREADY_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn txready(&mut self) -> TXREADY_W<0> {
                TXREADY_W::new(self)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            #[must_use]
            pub fn rxready(&mut self) -> RXREADY_W<1> {
                RXREADY_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [status::R](R) reader structure"]
        impl crate::Readable for STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
        impl crate::Writable for STATUS_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets STATUS to value 0"]
        impl crate::Resettable for STATUS_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "UART"]
    pub UART: UART,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            GPIO: GPIO {
                _marker: PhantomData,
            },
            UART: UART {
                _marker: PhantomData,
            },
        }
    }
}
