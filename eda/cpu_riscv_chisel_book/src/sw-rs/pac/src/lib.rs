#![doc = "Peripheral access API for CPU_RISCV_CHISEL_BOOK microcontrollers (generated using svd2rust v0.21.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.21.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(const_err)]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy;
    }
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also `modify`'ed."]
    pub trait Readable: RegisterSpec {
        #[doc = " Result from a call to `read` and argument to `modify`."]
        type Reader: From<R<Self>> + core::ops::Deref<Target = R<Self>>;
    }
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Writer type argument to `write`, et al."]
        type Writer: From<W<Self>> + core::ops::DerefMut<Target = W<Self>>;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        fn reset_value() -> Self::Ux;
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> REG::Reader {
            REG::Reader::from(R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            })
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::reset_value())
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::reset_value(),
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG>
    where
        REG::Ux: Default,
    {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                (*f(&mut REG::Writer::from(W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                })))
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&REG::Reader, &'w mut REG::Writer) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &REG::Reader::from(R {
                        bits,
                        _reg: marker::PhantomData,
                    }),
                    &mut REG::Writer::from(W {
                        bits,
                        _reg: marker::PhantomData,
                    }),
                )
                .bits,
            );
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub struct R<REG: RegisterSpec + ?Sized> {
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy + Into<REG::Ux>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&(*other).into())
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub struct W<REG: RegisterSpec + ?Sized> {
        #[doc = "Writable bits"]
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub struct FieldReader<U, T> {
        pub(crate) bits: U,
        _reg: marker::PhantomData<T>,
    }
    impl<U, T> FieldReader<U, T>
    where
        U: Copy,
    {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: U) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub fn bits(&self) -> U {
            self.bits
        }
    }
    impl<U, T, FI> PartialEq<FI> for FieldReader<U, T>
    where
        U: PartialEq,
        FI: Copy + Into<U>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&(*other).into())
        }
    }
    impl<FI> FieldReader<bool, FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    #[doc = " Access an array of `COUNT` items of type `T` with the items `STRIDE` bytes"]
    #[doc = " apart.  This is a zero-sized-type.  No objects of this type are ever"]
    #[doc = " actually created, it is only a convenience for wrapping pointer arithmetic."]
    #[doc = ""]
    #[doc = " There is no safe way to produce items of this type.  Unsafe code can produce"]
    #[doc = " references by pointer casting.  It is up to the unsafe code doing that, to"]
    #[doc = " ensure that the memory really is backed by appropriate content."]
    #[doc = ""]
    #[doc = " Typically, this is used for accessing hardware registers."]
    pub struct ArrayProxy<T, const COUNT: usize, const STRIDE: usize> {
        #[doc = " As well as providing a PhantomData, this field is non-public, and"]
        #[doc = " therefore ensures that code outside of this module can never create"]
        #[doc = " an ArrayProxy."]
        _array: marker::PhantomData<T>,
    }
    impl<T, const C: usize, const S: usize> ArrayProxy<T, C, S> {
        #[doc = " Get a reference from an [ArrayProxy] with no bounds checking."]
        pub unsafe fn get_ref(&self, index: usize) -> &T {
            let base = self as *const Self as usize;
            let address = base + S * index;
            &*(address as *const T)
        }
        #[doc = " Get a reference from an [ArrayProxy], or return `None` if the index"]
        #[doc = " is out of bounds."]
        pub fn get(&self, index: usize) -> Option<&T> {
            if index < C {
                Some(unsafe { self.get_ref(index) })
            } else {
                None
            }
        }
        #[doc = " Return the number of items."]
        pub fn len(&self) -> usize {
            C
        }
    }
    impl<T, const C: usize, const S: usize> core::ops::Index<usize> for ArrayProxy<T, C, S> {
        type Output = T;
        fn index(&self, index: usize) -> &T {
            [(); C][index];
            unsafe { self.get_ref(index) }
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 0] = [];
#[doc = "GPIO"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0xa000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "GPIO"]
pub mod gpio {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - "]
        pub data: crate::Reg<data::DATA_SPEC>,
    }
    #[doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
    pub type DATA = crate::Reg<data::DATA_SPEC>;
    #[doc = ""]
    pub mod data {
        #[doc = "Register `DATA` reader"]
        pub struct R(crate::R<DATA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATA_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `DATA` writer"]
        pub struct W(crate::W<DATA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATA_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
        pub struct DATA_SPEC;
        impl crate::RegisterSpec for DATA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [data::R](R) reader structure"]
        impl crate::Readable for DATA_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
        impl crate::Writable for DATA_SPEC {
            type Writer = W;
        }
        #[doc = "`reset()` method sets DATA to value 0"]
        impl crate::Resettable for DATA_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
#[doc = "Simple UART"]
pub struct UART {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART {}
impl UART {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0xb000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART").finish()
    }
}
#[doc = "Simple UART"]
pub mod uart {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved_0_rxd: [u8; 0x04],
        #[doc = "0x04 - "]
        pub status: crate::Reg<status::STATUS_SPEC>,
    }
    impl RegisterBlock {
        #[doc = "0x00 - "]
        #[inline(always)]
        pub fn rxd(&self) -> &crate::Reg<rxd::RXD_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(0usize)
                    as *const crate::Reg<rxd::RXD_SPEC>)
            }
        }
        #[doc = "0x00 - "]
        #[inline(always)]
        pub fn txd(&self) -> &crate::Reg<txd::TXD_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(0usize)
                    as *const crate::Reg<txd::TXD_SPEC>)
            }
        }
    }
    #[doc = "TXD register accessor: an alias for `Reg<TXD_SPEC>`"]
    pub type TXD = crate::Reg<txd::TXD_SPEC>;
    #[doc = ""]
    pub mod txd {
        #[doc = "Register `TXD` reader"]
        pub struct R(crate::R<TXD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TXD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TXD_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `TXD` writer"]
        pub struct W(crate::W<TXD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TXD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TXD_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `DATA` writer - "]
        pub struct DATA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn data(&mut self) -> DATA_W {
                DATA_W { w: self }
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txd](index.html) module"]
        pub struct TXD_SPEC;
        impl crate::RegisterSpec for TXD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [txd::R](R) reader structure"]
        impl crate::Readable for TXD_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [txd::W](W) writer structure"]
        impl crate::Writable for TXD_SPEC {
            type Writer = W;
        }
        #[doc = "`reset()` method sets TXD to value 0"]
        impl crate::Resettable for TXD_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    #[doc = "RXD register accessor: an alias for `Reg<RXD_SPEC>`"]
    pub type RXD = crate::Reg<rxd::RXD_SPEC>;
    #[doc = ""]
    pub mod rxd {
        #[doc = "Register `RXD` reader"]
        pub struct R(crate::R<RXD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RXD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RXD_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `RXD` writer"]
        pub struct W(crate::W<RXD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RXD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RXD_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `RXD` reader - "]
        pub struct RXD_R(crate::FieldReader<u8, u8>);
        impl RXD_R {
            #[inline(always)]
            pub(crate) fn new(bits: u8) -> Self {
                RXD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RXD_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn rxd(&self) -> RXD_R {
                RXD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxd](index.html) module"]
        pub struct RXD_SPEC;
        impl crate::RegisterSpec for RXD_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [rxd::R](R) reader structure"]
        impl crate::Readable for RXD_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [rxd::W](W) writer structure"]
        impl crate::Writable for RXD_SPEC {
            type Writer = W;
        }
        #[doc = "`reset()` method sets RXD to value 0"]
        impl crate::Resettable for RXD_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    #[doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    #[doc = ""]
    pub mod status {
        #[doc = "Register `STATUS` reader"]
        pub struct R(crate::R<STATUS_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATUS_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATUS_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `STATUS` writer"]
        pub struct W(crate::W<STATUS_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATUS_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATUS_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATUS_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXREADY_A {
            #[doc = "1: `1`"]
            READY = 1,
            #[doc = "0: `0`"]
            NOTREADY = 0,
        }
        impl From<TXREADY_A> for bool {
            #[inline(always)]
            fn from(variant: TXREADY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TXREADY` reader - "]
        pub struct TXREADY_R(crate::FieldReader<bool, TXREADY_A>);
        impl TXREADY_R {
            #[inline(always)]
            pub(crate) fn new(bits: bool) -> Self {
                TXREADY_R(crate::FieldReader::new(bits))
            }
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXREADY_A {
                match self.bits {
                    true => TXREADY_A::READY,
                    false => TXREADY_A::NOTREADY,
                }
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                **self == TXREADY_A::READY
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_notready(&self) -> bool {
                **self == TXREADY_A::NOTREADY
            }
        }
        impl core::ops::Deref for TXREADY_R {
            type Target = crate::FieldReader<bool, TXREADY_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        #[doc = "Field `TXREADY` writer - "]
        pub struct TXREADY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXREADY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXREADY_A) -> &'a mut W {
                self.bit(variant.into())
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ready(self) -> &'a mut W {
                self.variant(TXREADY_A::READY)
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn notready(self) -> &'a mut W {
                self.variant(TXREADY_A::NOTREADY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXREADY_A {
            #[doc = "1: `1`"]
            READY = 1,
            #[doc = "0: `0`"]
            NOTREADY = 0,
        }
        impl From<RXREADY_A> for bool {
            #[inline(always)]
            fn from(variant: RXREADY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RXREADY` reader - "]
        pub struct RXREADY_R(crate::FieldReader<bool, RXREADY_A>);
        impl RXREADY_R {
            #[inline(always)]
            pub(crate) fn new(bits: bool) -> Self {
                RXREADY_R(crate::FieldReader::new(bits))
            }
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXREADY_A {
                match self.bits {
                    true => RXREADY_A::READY,
                    false => RXREADY_A::NOTREADY,
                }
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                **self == RXREADY_A::READY
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_notready(&self) -> bool {
                **self == RXREADY_A::NOTREADY
            }
        }
        impl core::ops::Deref for RXREADY_R {
            type Target = crate::FieldReader<bool, RXREADY_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        #[doc = "Field `RXREADY` writer - "]
        pub struct RXREADY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXREADY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXREADY_A) -> &'a mut W {
                self.bit(variant.into())
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ready(self) -> &'a mut W {
                self.variant(RXREADY_A::READY)
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn notready(self) -> &'a mut W {
                self.variant(RXREADY_A::NOTREADY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn txready(&self) -> TXREADY_R {
                TXREADY_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn rxready(&self) -> RXREADY_R {
                RXREADY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn txready(&mut self) -> TXREADY_W {
                TXREADY_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn rxready(&mut self) -> RXREADY_W {
                RXREADY_W { w: self }
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [status::R](R) reader structure"]
        impl crate::Readable for STATUS_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
        impl crate::Writable for STATUS_SPEC {
            type Writer = W;
        }
        #[doc = "`reset()` method sets STATUS to value 0"]
        impl crate::Resettable for STATUS_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "UART"]
    pub UART: UART,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        riscv::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            GPIO: GPIO {
                _marker: PhantomData,
            },
            UART: UART {
                _marker: PhantomData,
            },
        }
    }
}
